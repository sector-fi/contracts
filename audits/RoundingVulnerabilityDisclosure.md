### Critical bug disclosure

- **Author**: [@nem_veer](https://twitter.com/nem_veer)
- **Title**: Manipulation of **scToken** when totalSupply is zero can lead to implicit minimum deposit amount and loss of user funds due to rounding errors.

- **Severity**: Critical
- **Difficulty to exploit**: Easy

- **Where**: All Vault contract
- **When**: When totalSupply of scToken == 0

### **Description**

- **Attack**

  When totalSupply is zero an attacker goes ahead and executes the following steps

  1. They use some amount of underlying tokens to [deposit](https://github.com/scion-finance/contracts/blob/dev/src/vault/VaultUpgradable.sol#L381).

  - They will be minted some [BASE_UNIT](https://github.com/scion-finance/contracts/blob/dev/src/vault/VaultUpgradable.sol#L478) amount of scToken because totalSupply is zero.

  2. They [withdraw](https://github.com/scion-finance/contracts/blob/dev/src/vault/VaultUpgradable.sol#L398) all their underlying except 1 wei worth of scToken.
  3. They transfer z underlying tokens directly to Vault contract address

  - This leads to 1 wei of scToken worth z (+ some small amount).
  - The attacker won't have any problem making this z as big as possible as they have all the
    claim to it as a holder of 1 Wei of scToken.

### **This attack has two implications**:

1. The first deposit can be front run and stolen

- Let's assume there is a first user trying to mint some scToken using
  their k\*z underlying tokens.
- An attacker can see this transaction and carry out the above-described attack making sure
  that k<1.
- This leads to the first depositor getting zero scToken for their k\*z underlying tokens. Thus 100% loss of funds.
- All upcoming depositor with k<1, would face the same.
- All the tokens are redeemable by the attacker using their 1 wei of scToken.

2. Implicit minimum Amount and funds lost due to rounding errors

- If an attacker is successful in making 1 wei of scToken worth z underlying tokens and a
  user tries to mint scToken using k\* z underlying tokens then,
  1. If k<1, then the user gets zero scToken and all of their underlying tokens get
     proportionally divided between scToken holders
     - This leads to an implicit minimum amount for a user at the attacker's discretion.
  2. If k>1, then users still get some scToken but they lose (k- floor(k)) \* z) of underlying
     tokens which get proportionally divided between scToken holders due to rounding
     errors.
     - This means that for users to not lose value, they must make sure that k is an integer.
- Attacker can keep 2 wei instead of 1 too. But that would require double the capital. But then attack would be more powerful.

### **Impact**:

1. Direct theft of any user funds, whether at-rest or in-motion, other than unclaimed yield
2. It is hard to put a number on the funds that can be affected because the value loss keeps happening until the detection of the bug.
3. Here we have factory for vault deployment, It only makes it easier for attackers. Each time new vault is deployed from factory, attacker can attack it.
4. Attack could have happened when Vault was deployed and users funds could have been at risk.
5. If totalSupply of any Vault again becomes zero, then all depositor funds can be on risk until the attack is noticed.

### **Recommendations**:

1. For already deployed Vault send some scToken to a dead address to make sure that the total supply never goes to zero
2. For new Vault, I like how [BalancerV2](https://github.com/balancer-labs/balancer-v2-monorepo/blob/master/pkg/pool-utils/contracts/BasePool.sol#L269-L283) and [UniswapV2](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L121) do it, some minimum amount of pool tokens get burnt when the first mint happens.

### **Status**:

The Secion team has take the suggested steps to mitigate the vulnerability in deployed contracts and updated the contract code.
